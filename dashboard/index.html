<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>HiPerGator Usage Dashboard</title>
<script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
<style>
:root {
  --bg: #ffffff;
  --bg-secondary: #f5f5f5;
  --text: #1a1a1a;
  --text-secondary: #555;
  --border: #ddd;
  --accent: #2563eb;
  --accent-hover: #1d4ed8;
  --tab-bg: #e5e7eb;
  --tab-active: #2563eb;
  --tab-active-text: #fff;
  --table-stripe: #f9fafb;
  --plot-bg: #ffffff;
  --plot-grid: #e5e7eb;
  --plot-text: #1a1a1a;
}
[data-theme="dark"] {
  --bg: #1a1a2e;
  --bg-secondary: #16213e;
  --text: #e0e0e0;
  --text-secondary: #aaa;
  --border: #333;
  --accent: #4f8cff;
  --accent-hover: #3b6fcc;
  --tab-bg: #2a2a4a;
  --tab-active: #4f8cff;
  --tab-active-text: #fff;
  --table-stripe: #1e1e3a;
  --plot-bg: #1a1a2e;
  --plot-grid: #333;
  --plot-text: #e0e0e0;
}
* { box-sizing: border-box; margin: 0; padding: 0; }
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: var(--bg);
  color: var(--text);
  transition: background 0.3s, color 0.3s;
}
.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 24px;
  border-bottom: 1px solid var(--border);
}
.header h1 { font-size: 1.4rem; }
.header-right { display: flex; gap: 12px; align-items: center; }
.last-updated { font-size: 0.85rem; color: var(--text-secondary); }
.dark-toggle {
  background: var(--tab-bg);
  border: 1px solid var(--border);
  color: var(--text);
  padding: 6px 12px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.85rem;
}
.tabs {
  display: flex;
  gap: 4px;
  padding: 12px 24px;
  background: var(--bg-secondary);
}
.tab {
  padding: 8px 20px;
  border: none;
  background: var(--tab-bg);
  color: var(--text);
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.9rem;
  font-weight: 500;
}
.tab.active {
  background: var(--tab-active);
  color: var(--tab-active-text);
}
.controls {
  display: flex;
  gap: 8px;
  padding: 12px 24px;
  align-items: center;
  flex-wrap: wrap;
}
.controls label { font-size: 0.85rem; font-weight: 600; margin-right: 4px; }
.range-btn {
  padding: 5px 14px;
  border: 1px solid var(--border);
  background: var(--bg);
  color: var(--text);
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.82rem;
}
.range-btn.active {
  background: var(--accent);
  color: #fff;
  border-color: var(--accent);
}
.date-input {
  padding: 4px 8px;
  border: 1px solid var(--border);
  background: var(--bg);
  color: var(--text);
  border-radius: 4px;
  font-size: 0.82rem;
  font-family: inherit;
}
.date-input::-webkit-calendar-picker-indicator {
  filter: var(--cal-filter, none);
}
[data-theme="dark"] { --cal-filter: invert(0.8); }
.date-apply {
  padding: 5px 14px;
  border: 1px solid var(--accent);
  background: var(--accent);
  color: #fff;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.82rem;
}
.date-reset {
  padding: 5px 10px;
  border: 1px solid var(--border);
  background: var(--bg);
  color: var(--text);
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.82rem;
}
.separator {
  width: 1px;
  height: 20px;
  background: var(--border);
  margin: 0 4px;
}
.grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
  padding: 12px 24px;
}
@media (max-width: 900px) {
  .grid { grid-template-columns: 1fr; }
}
.chart-container {
  background: var(--bg-secondary);
  border-radius: 8px;
  border: 1px solid var(--border);
  overflow: hidden;
}
.chart-box { width: 100%; height: 380px; }
.drain-chart-box { width: 100%; height: 500px; }
.table-section {
  padding: 12px 24px 24px;
}
.table-section h2 {
  font-size: 1.1rem;
  margin-bottom: 8px;
}
table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.85rem;
}
th, td {
  text-align: left;
  padding: 8px 12px;
  border-bottom: 1px solid var(--border);
}
th { font-weight: 600; background: var(--bg-secondary); }
tr:nth-child(even) { background: var(--table-stripe); }
#drain-section { display: none; }
#qos-section { display: block; }
.status-bar {
  padding: 4px 24px;
  font-size: 0.78rem;
  color: var(--text-secondary);
}
</style>
</head>
<body>

<div class="header">
  <h1>HiPerGator Usage Dashboard</h1>
  <div class="header-right">
    <span class="last-updated" id="last-updated"></span>
    <button class="dark-toggle" id="dark-toggle">Dark Mode</button>
  </div>
</div>

<div class="tabs">
  <button class="tab active" data-tab="avery">avery</button>
  <button class="tab" data-tab="avery-b">avery-b</button>
  <button class="tab" data-tab="drain">drain</button>
</div>

<div id="qos-section">
  <div class="controls">
    <label>Time Range:</label>
    <button class="range-btn" data-hours="6">6h</button>
    <button class="range-btn" data-hours="12">12h</button>
    <button class="range-btn" data-hours="24">24h</button>
    <button class="range-btn" data-hours="72">3d</button>
    <button class="range-btn" data-hours="168">7d</button>
    <button class="range-btn" data-hours="336">14d</button>
    <button class="range-btn active" data-hours="720">30d</button>
    <div class="separator"></div>
    <label>From:</label>
    <input type="datetime-local" class="date-input" id="date-start">
    <label>To:</label>
    <input type="datetime-local" class="date-input" id="date-end">
    <button class="date-apply" id="date-apply">Apply</button>
    <button class="date-reset" id="date-reset">Reset</button>
  </div>
  <div class="grid">
    <div class="chart-container"><div id="chart-NCPUS" class="chart-box"></div></div>
    <div class="chart-container"><div id="chart-NGPUS" class="chart-box"></div></div>
    <div class="chart-container"><div id="chart-MEMORY" class="chart-box"></div></div>
    <div class="chart-container"><div id="chart-NJOBS" class="chart-box"></div></div>
  </div>
  <div class="table-section">
    <h2>Current User Usage (Last Time Bin)</h2>
    <table id="user-table">
      <thead><tr><th>User</th><th>CPUs</th><th>GPUs</th><th>Memory (GB)</th><th>Jobs</th></tr></thead>
      <tbody></tbody>
    </table>
  </div>
  <div class="table-section">
    <h2>Total Usage Per User (Visible Range, CPU-hours)</h2>
    <table id="total-table">
      <thead><tr><th>User</th><th>CPU-hours</th><th>GPU-hours</th><th>Memory-GB-hours</th><th>Job-hours</th></tr></thead>
      <tbody></tbody>
    </table>
  </div>
</div>

<div id="drain-section">
  <div class="grid" style="grid-template-columns:1fr;">
    <div class="chart-container"><div id="chart-drain" class="drain-chart-box"></div></div>
  </div>
</div>

<div class="status-bar" id="status-bar">Loading...</div>

<script>
(function() {
  const DATA_FILES = {
    'avery': 'data_avery.json',
    'avery-b': 'data_avery-b.json',
  };
  const DRAIN_FILE = 'drain_data.json';
  const REFRESH_MS = 5 * 60 * 1000;
  const OBS_KEYS = ['NCPUS', 'NGPUS', 'MEMORY', 'NJOBS'];

  let currentTab = 'avery';
  let currentHours = 720;
  let customStart = null;
  let customEnd = null;
  let cache = {};
  let drainCache = null;
  let darkMode = localStorage.getItem('darkMode') === 'true';

  if (darkMode) document.documentElement.setAttribute('data-theme', 'dark');

  // Elements
  const tabs = document.querySelectorAll('.tab');
  const rangeBtns = document.querySelectorAll('.range-btn');
  const darkToggle = document.getElementById('dark-toggle');
  const lastUpdatedEl = document.getElementById('last-updated');
  const statusBar = document.getElementById('status-bar');

  // Tab switching
  tabs.forEach(t => t.addEventListener('click', () => {
    tabs.forEach(x => x.classList.remove('active'));
    t.classList.add('active');
    currentTab = t.dataset.tab;
    if (currentTab === 'drain') {
      document.getElementById('qos-section').style.display = 'none';
      document.getElementById('drain-section').style.display = 'block';
      renderDrain();
    } else {
      document.getElementById('qos-section').style.display = 'block';
      document.getElementById('drain-section').style.display = 'none';
      renderQoS();
    }
  }));

  // Time range preset buttons
  rangeBtns.forEach(b => b.addEventListener('click', () => {
    rangeBtns.forEach(x => x.classList.remove('active'));
    b.classList.add('active');
    currentHours = parseInt(b.dataset.hours);
    customStart = null;
    customEnd = null;
    document.getElementById('date-start').value = '';
    document.getElementById('date-end').value = '';
    renderQoS();
  }));

  // Custom date range
  document.getElementById('date-apply').addEventListener('click', () => {
    const startVal = document.getElementById('date-start').value;
    const endVal = document.getElementById('date-end').value;
    if (!startVal && !endVal) return;
    customStart = startVal ? new Date(startVal) : null;
    customEnd = endVal ? new Date(endVal) : null;
    rangeBtns.forEach(x => x.classList.remove('active'));
    renderQoS();
  });

  document.getElementById('date-reset').addEventListener('click', () => {
    customStart = null;
    customEnd = null;
    document.getElementById('date-start').value = '';
    document.getElementById('date-end').value = '';
    rangeBtns.forEach(x => x.classList.remove('active'));
    document.querySelector('.range-btn[data-hours="720"]').classList.add('active');
    currentHours = 720;
    renderQoS();
  });

  // Dark mode
  darkToggle.addEventListener('click', () => {
    darkMode = !darkMode;
    localStorage.setItem('darkMode', darkMode);
    if (darkMode) {
      document.documentElement.setAttribute('data-theme', 'dark');
    } else {
      document.documentElement.removeAttribute('data-theme');
    }
    darkToggle.textContent = darkMode ? 'Light Mode' : 'Dark Mode';
    if (currentTab === 'drain') renderDrain();
    else renderQoS();
  });
  darkToggle.textContent = darkMode ? 'Light Mode' : 'Dark Mode';

  function getPlotColors() {
    return {
      bg: getComputedStyle(document.documentElement).getPropertyValue('--plot-bg').trim(),
      grid: getComputedStyle(document.documentElement).getPropertyValue('--plot-grid').trim(),
      text: getComputedStyle(document.documentElement).getPropertyValue('--plot-text').trim(),
    };
  }

  async function fetchJSON(url) {
    const resp = await fetch(url + '?t=' + Date.now());
    if (!resp.ok) throw new Error('Failed to fetch ' + url + ': ' + resp.status);
    return resp.json();
  }

  async function loadData() {
    try {
      const [avery, averyb, drain] = await Promise.all([
        fetchJSON(DATA_FILES['avery']),
        fetchJSON(DATA_FILES['avery-b']),
        fetchJSON(DRAIN_FILE).catch(() => null),
      ]);
      cache['avery'] = avery;
      cache['avery-b'] = averyb;
      drainCache = drain;
      statusBar.textContent = 'Data loaded at ' + new Date().toLocaleTimeString();
      if (avery.metadata.last_updated) {
        lastUpdatedEl.textContent = 'Updated: ' + avery.metadata.last_updated;
      }
    } catch (e) {
      statusBar.textContent = 'Error loading data: ' + e.message;
      console.error(e);
    }
  }

  function filterByRange(times) {
    let startIdx = 0;
    let endIdx = times.length;

    if (customStart || customEnd) {
      const s = customStart || new Date(0);
      const e = customEnd || new Date(8640000000000000);
      for (let i = 0; i < times.length; i++) {
        if (new Date(times[i]) >= s) { startIdx = i; break; }
      }
      for (let i = times.length - 1; i >= startIdx; i--) {
        if (new Date(times[i]) <= e) { endIdx = i + 1; break; }
      }
    } else {
      const cutoff = new Date(Date.now() - currentHours * 3600 * 1000);
      for (let i = 0; i < times.length; i++) {
        if (new Date(times[i]) >= cutoff) { startIdx = i; break; }
      }
    }
    return { startIdx, endIdx };
  }

  function renderQoS() {
    const data = cache[currentTab];
    if (!data) return;

    const colors = getPlotColors();
    const times = data.time_idxs;
    const { startIdx, endIdx } = filterByRange(times);
    const filteredTimes = times.slice(startIdx, endIdx);

    OBS_KEYS.forEach(obsKey => {
      const obsData = data.observables[obsKey];
      if (!obsData) return;

      const traces = data.users.map(user => {
        const vals = obsData[user];
        if (!vals) return null;
        return {
          x: filteredTimes,
          y: vals.slice(startIdx, endIdx),
          name: user,
          type: 'scatter',
          mode: 'none',
          stackgroup: 'one',
          line: { width: 0 },
          hovertemplate: '%{y:.1f}<extra>%{fullData.name}</extra>',
        };
      }).filter(Boolean);

      const threshold = data.thresholds[obsKey];
      const shapes = [];
      if (threshold && threshold > 0) {
        shapes.push({
          type: 'line',
          x0: filteredTimes[0],
          x1: filteredTimes[filteredTimes.length - 1],
          y0: threshold,
          y1: threshold,
          line: { color: 'red', dash: 'dash', width: 2 },
          layer: 'above',
        });
      }

      const niceName = data.nice_names[obsKey] || obsKey;
      const thresholdAnnotation = (threshold && threshold > 0) ? [{
        x: filteredTimes[filteredTimes.length - 1],
        y: threshold,
        text: 'Limit: ' + threshold,
        showarrow: false,
        font: { color: 'red', size: 10 },
        xanchor: 'right',
        yanchor: 'bottom',
      }] : [];
      const layout = {
        title: { text: niceName + ' (' + currentTab + ')', font: { size: 14, color: colors.text } },
        hovermode: 'x unified',
        showlegend: true,
        legend: { font: { size: 10, color: colors.text }, bgcolor: 'rgba(0,0,0,0)' },
        margin: { l: 50, r: 20, t: 40, b: 50 },
        paper_bgcolor: colors.bg,
        plot_bgcolor: colors.bg,
        xaxis: { gridcolor: colors.grid, tickfont: { color: colors.text } },
        yaxis: { gridcolor: colors.grid, tickfont: { color: colors.text }, title: { text: niceName, font: { color: colors.text } }, rangemode: 'tozero' },
        shapes: shapes,
        annotations: thresholdAnnotation,
      };

      Plotly.react('chart-' + obsKey, traces, layout, { responsive: true, displayModeBar: true });
    });

    renderUserTable(data, startIdx);
    renderTotalTable(data, startIdx, endIdx);
  }

  function renderUserTable(data, startIdx) {
    const tbody = document.querySelector('#user-table tbody');
    tbody.innerHTML = '';

    const rows = [];
    data.users.forEach(user => {
      const cpus = lastVal(data.observables.NCPUS, user);
      const gpus = lastVal(data.observables.NGPUS, user);
      const mem = lastVal(data.observables.MEMORY, user);
      const jobs = lastVal(data.observables.NJOBS, user);
      const total = cpus + gpus * 10 + mem + jobs;
      if (total > 0) rows.push({ user, cpus, gpus, mem, jobs, total });
    });

    rows.sort((a, b) => b.total - a.total);

    rows.forEach(r => {
      const tr = document.createElement('tr');
      tr.innerHTML = '<td>' + r.user + '</td><td>' + r.cpus.toFixed(1) + '</td><td>' + r.gpus.toFixed(1) + '</td><td>' + r.mem.toFixed(1) + '</td><td>' + r.jobs.toFixed(1) + '</td>';
      tbody.appendChild(tr);
    });
  }

  function lastVal(obsObj, user) {
    if (!obsObj || !obsObj[user]) return 0;
    const arr = obsObj[user];
    for (let i = arr.length - 1; i >= 0; i--) {
      if (arr[i] !== 0) return arr[i];
    }
    return 0;
  }

  function renderTotalTable(data, startIdx, endIdx) {
    const tbody = document.querySelector('#total-table tbody');
    tbody.innerHTML = '';
    const binHours = data.metadata.time_resolution_seconds / 3600;

    const rows = [];
    data.users.forEach(user => {
      const sum = (obsKey) => {
        const arr = data.observables[obsKey] && data.observables[obsKey][user];
        if (!arr) return 0;
        let s = 0;
        for (let i = startIdx; i < endIdx; i++) s += arr[i];
        return s * binHours;
      };
      const cpuH = sum('NCPUS');
      const gpuH = sum('NGPUS');
      const memH = sum('MEMORY');
      const jobH = sum('NJOBS');
      const total = cpuH + gpuH + memH;
      if (total > 0) rows.push({ user, cpuH, gpuH, memH, jobH, total });
    });

    rows.sort((a, b) => b.total - a.total);

    rows.forEach(r => {
      const tr = document.createElement('tr');
      tr.innerHTML = '<td>' + r.user + '</td><td>' + r.cpuH.toFixed(1) + '</td><td>' + r.gpuH.toFixed(1) + '</td><td>' + r.memH.toFixed(1) + '</td><td>' + r.jobH.toFixed(1) + '</td>';
      tbody.appendChild(tr);
    });
  }

  function renderDrain() {
    if (!drainCache) {
      Plotly.react('chart-drain', [], { title: 'No drain data available' }, { responsive: true });
      return;
    }
    const colors = getPlotColors();
    const traces = [{
      x: drainCache.timestamps,
      y: drainCache.values,
      type: 'scatter',
      mode: 'lines+markers',
      name: 'CPUs to drain',
      line: { color: '#4f8cff' },
      marker: { size: 3 },
    }];
    const layout = {
      title: { text: 'CPUs to be Drained', font: { size: 16, color: colors.text } },
      hovermode: 'x unified',
      margin: { l: 60, r: 20, t: 50, b: 50 },
      paper_bgcolor: colors.bg,
      plot_bgcolor: colors.bg,
      xaxis: { gridcolor: colors.grid, tickfont: { color: colors.text }, title: { text: 'Time', font: { color: colors.text } } },
      yaxis: { gridcolor: colors.grid, tickfont: { color: colors.text }, title: { text: 'N CPUs', font: { color: colors.text } }, rangemode: 'tozero' },
    };
    Plotly.react('chart-drain', traces, layout, { responsive: true, displayModeBar: true });
  }

  async function init() {
    await loadData();
    renderQoS();
    setInterval(async () => {
      await loadData();
      if (currentTab === 'drain') renderDrain();
      else renderQoS();
    }, REFRESH_MS);
  }

  init();
})();
</script>
</body>
</html>
